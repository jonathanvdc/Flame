<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Flame.DSharp</name>
  </assembly>
  <members>
    <member name="T:Flame.DSharp.Lexer.TokenType">
      <summary> Tokens is an enumeration of all possible token values. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Next()">
      <summary> Gets the next token in queue. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Returns the token that immediately trails the token with the given position. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Sets the current parser position. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Reset()">
      <summary> Resets the token stream. </summary>
    </member>
    <member name="P:Flame.DSharp.Lexer.ITokenStream.CurrentPosition">
      <summary> Gets the token stream's current position. </summary>
    </member>
    <member name="T:Flame.DSharp.Lexer.PeekToken">
      <summary> A PeekToken object type </summary>
      <remarks> A PeekToken is a special pointer object that can be used to Peek() several tokens ahead in the GetToken() queue. </remarks>
    </member>
    <member name="T:Flame.DSharp.Lexer.Token">
      <summary> A Token object type </summary>
      <remarks> A Token object holds the token and token value. </remarks>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Next()">
      <summary> Gets the next token in queue. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Reset()">
      <summary> Resets the token stream. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Returns the token that immediately trails the token with the given position. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Sets the current parser position. </summary>
    </member>
    <member name="T:Flame.DSharp.Lexer.TokenParser">
      <summary> TokenParser </summary>
      <remarks> TokenParser is the main parser engine for converting input into lexical tokens. </remarks>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenParser.PrepareRegex()">
      <summary> PrepareRegex prepares the regex for parsing by pre-matching the Regex tokens. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenParser.ResetParser()">
      <summary> ResetParser resets the parser to its inital state. Reloading InputString is required. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenParser.Reset()">
      <summary> Resets the token stream. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenParser.Next()">
      <summary> GetToken gets the next token in queue </summary>
      <remarks> GetToken attempts to the match the next character(s) using the Regex rules defined in the dictionary. If a match can not be located, then an Undefined token will be created with an empty string value. In addition, the token pointer will be incremented by one so that this token doesn't attempt to get identified again by GetToken() </remarks>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenParser.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Returns the next token after the provided position </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenParser.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Sets the current parser position. </summary>
    </member>
    <member name="P:Flame.DSharp.Lexer.TokenParser.InputString">
      <summary> InputString Property </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsPrefixTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary> Gets a boolean value that indicates if this type token is followed by another type token. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary> Gets a boolean value that indicates if this token could be used to construct a type. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsSuffixTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary> Gets a boolean value that indicates if this type token can trail another type token. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsPrefixOrSuffixTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary> Gets a boolean value that indicates if this type token can trail another type token. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.Peek(Flame.DSharp.Lexer.ITokenStream)">
      <summary> Returns the next token, without altering the token stream's state. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.Peek(Flame.DSharp.Lexer.ITokenStream,Flame.DSharp.Lexer.PeekToken)">
      <summary> Returns the next token after the provided token. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.NextBlockContents(Flame.DSharp.Lexer.ITokenStream,Flame.DSharp.Lexer.TokenType,Flame.DSharp.Lexer.TokenType)">
      <summary> Reads the contents of a "block", delimited by a start and an end token. The end token will also be parsed by this method, but will not be added to the results. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Next()">
      <summary> Gets the next token in queue. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Sets the current parser position. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary> Returns the token that immediately trails the token with the given position. </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Reset()">
      <summary> Resets the token stream. </summary>
    </member>
    <member name="T:Flame.DSharp.Parser.DSharpSyntaxParser">
      <summary> The D# syntax parser. </summary>
      <remarks> This is where the magic happens. </remarks>
    </member>
    <member name="M:Flame.DSharp.Parser.DSharpSyntaxParser.ParseAmbiguousAttributes(Flame.DSharp.Lexer.ITokenStream)">
      <summary> Parses a list of attributes that may or may not be trailed by an enumerator, which uses the same syntax. </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxTypeBase.AssociatedTypes">
      <summary> Gets all associated types for this type. </summary>
    </member>
    <member name="M:Flame.DSharp.Build.SyntaxAssembly.AddCompilationUnit(Flame.Syntax.ICompilationUnit,Flame.Compiler.ICompilerLog)">
      <summary> Adds a compilation unit to the assembly. </summary>
    </member>
    <member name="M:Flame.DSharp.Build.SyntaxAssembly.CreateBinder()">
      <summary> Creates a binder for this assembly. </summary>
    </member>
    <member name="M:Flame.DSharp.Build.SyntaxAssembly.GetEntryPoint()">
      <summary> Gets the entry point method for this assembly. </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.RootNamespace">
      <summary> Gets the nameless root namespace of the assembly. </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.AllTypes">
      <summary> Gets all types in the assembly. </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.AssemblyVersion">
      <summary> Gets the assembly's version. </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.MainNamespace">
      <summary> Gets the nameless root namespace of the assembly. </summary>
    </member>
    <member name="T:Flame.Syntax.DSharp.FieldProperty">
      <summary> Describes a property backed by a field. </summary>
    </member>
  </members>
</doc>